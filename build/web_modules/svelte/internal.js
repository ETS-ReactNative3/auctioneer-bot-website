function h(){}function k(t){return t()}function E(){return Object.create(null)}function c(t){t.forEach(k)}function D(t){return typeof t=="function"}function q(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}function B(t){return Object.keys(t).length===0}function P(t,e){t.appendChild(e)}function z(t,e,n){t.insertBefore(e,n||null)}function O(t){t.parentNode.removeChild(t)}function F(t){return document.createElement(t)}function G(t){return document.createTextNode(t)}function H(){return G(" ")}function I(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function J(t){return Array.from(t.childNodes)}let j;function _(t){j=t}const a=[],A=[],l=[],C=[],K=Promise.resolve();let m=!1;function L(){m||(m=!0,K.then(M))}function g(t){l.push(t)}let y=!1;const $=new Set();function M(){if(y)return;y=!0;do{for(let t=0;t<a.length;t+=1){const e=a[t];_(e),Q(e.$$)}for(a.length=0;A.length;)A.pop()();for(let t=0;t<l.length;t+=1){const e=l[t];$.has(e)||($.add(e),e())}l.length=0}while(a.length);for(;C.length;)C.pop()();m=!1,y=!1,$.clear()}function Q(t){if(t.fragment!==null){t.update(),c(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(g)}}const d=new Set();let R;function N(t,e){t&&t.i&&(d.delete(t),t.i(e))}function V(t,e,n,i){if(t&&t.o){if(d.has(t))return;d.add(t),R.c.push(()=>{d.delete(t),i&&(n&&t.d(1),i())}),t.o(e)}}function W(t){t&&t.c()}function S(t,e,n){const{fragment:i,on_mount:u,on_destroy:f,after_update:p}=t.$$;i&&i.m(e,n),g(()=>{const s=u.map(k).filter(D);f?f.push(...s):c(s),t.$$.on_mount=[]}),p.forEach(g)}function T(t,e){const n=t.$$;n.fragment!==null&&(c(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function X(t,e){t.$$.dirty[0]===-1&&(a.push(t),L(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function Y(t,e,n,i,u,f,p=[-1]){const s=j;_(t);const U=e.props||{},o=t.$$={fragment:null,ctx:null,props:f,update:h,not_equal:u,bound:E(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(s?s.$$.context:[]),callbacks:E(),dirty:p,skip_bound:!1};let b=!1;if(o.ctx=n?n(t,U,(r,x,...w)=>{const v=w.length?w[0]:x;return o.ctx&&u(o.ctx[r],o.ctx[r]=v)&&(!o.skip_bound&&o.bound[r]&&o.bound[r](v),b&&X(t,r)),x}):[],o.update(),b=!0,c(o.before_update),o.fragment=i?i(o.ctx):!1,e.target){if(e.hydrate){const r=J(e.target);o.fragment&&o.fragment.l(r),r.forEach(O)}else o.fragment&&o.fragment.c();e.intro&&N(t.$$.fragment),S(t,e.target,e.anchor),M()}_(s)}class Z{$destroy(){T(this,1),this.$destroy=h}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const i=n.indexOf(e);i!==-1&&n.splice(i,1)}}$set(t){this.$$set&&!B(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}export{Z as SvelteComponent,P as append,I as attr,W as create_component,T as destroy_component,O as detach,F as element,Y as init,z as insert,S as mount_component,h as noop,q as safe_not_equal,H as space,N as transition_in,V as transition_out};
